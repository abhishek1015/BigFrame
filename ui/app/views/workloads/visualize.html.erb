<script src="http://d3js.org/d3.v3.min.js"></script>
<style>

#visualization
{
border:2px solid;
border-radius:25px;
}

node {
  stroke: #fff;
  stroke-width: 1.5px;
}

path.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

text {
  fill: #000;
  font: 10px sans-serif;
  pointer-events: none;
}

svg body {
  color: transparent;
background: transparent;
}
svg div { 
  border-radius: 8px;
}
</style>
<body>

<div id="visualization">
</div>
<script>

var json=<%=raw @jsondata.to_json%>;
var width = 1100;
var height = 500;
var color = d3.scale.category10();
var force=d3.layout.force()
var nodes=json["jobs"];
var links=[];
//generate links dynamically with dependentChildren field
for (var i=0;i<nodes.length;i++){
  for (var j=0;j<nodes[i]["dependentChildren"].length;j++){
      //get the children field of each node
  //set a link between the current node i and the index of the target node, found by looping
  links.push({"source":i,"target":findIndexById(nodes[i]["dependentChildren"][j])});
  }
}

function findIndexById(id){
for (var i=0;i<nodes.length;i++){
  if (nodes[i].jobId==id){
    return i;
  }
}
return -1;
}

var svg = d3.select("#visualization").append("svg")
  .attr("width", width)
  .attr("height", height);

console.log(nodes);

//make arrows
svg.append("svg:defs").selectAll("marker")
    .data(["end"])
  .enter().append("svg:marker")
    .attr("id", String)
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 40)
    .attr("refY", -2.0)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("svg:path")
    .attr("d", "M0,-5L10,0L0,5");

force
    .nodes(nodes)
    .links(links)
    .size([width, height])
    .linkDistance(300)
    .charge(-1000)
    .on("tick", tick)
    .start();

//create paths
path = svg.append("svg:g").selectAll("path")
    .data(force.links())
  .enter().append("svg:path")
    .attr("class", "link")
    .attr("marker-end", function(d) { return "url(#end)"; })
    .attr("id", 
              function(d) { 
                 return "path"+d.source.index+"_"+d.target.index; 
              }) 
       .attr("d", 
              function(d) { 
                 return moveto(d) + lineto(d); 
              }); 

/*
//create edge labels
label = svg.selectAll("text") 
       .data(force.links()) 
       .enter().append("svg:text") 
       .attr("font-size", 10) 
       .attr("dx", 40)
       .append("svg:textPath") 
       .attr("xlink:href", 
              function(d) { 
                 return "#path"+d.source.index+"_"+d.target.index; 
              });
*/

var pi=Math.PI;
//find number of varieties in node
//figure out how many are graph, relational, nested
//define color constants for each type, relational=blue, graph=orange, nested=green
var varietyColorMap={"relational":0, "graph":1, "nested":2};

for (var i=0;i<nodes.length;i++){
  hash={"relational":0, "graph":0, "nested":0};
  for (var j=0;j<nodes[i].rootInputPath.length;j++){
    for (var key in hash){
       if (nodes[i].rootInputPath[j].indexOf(key)>=0){
        hash[key]=hash[key]+1;
       }
    }
}
array=[];
for (var key in hash){
  obj={};
  obj["group"]=key;
  obj["value"]=hash[key]
  array.push(obj);
}
//create new field dataVarieties to track counts
nodes[i]["dataVarieties"]=array;
}

   var pie = d3.layout.pie()
        .sort(null)
        .value(function(d) { return d.value; });

  var arc = d3.svg.arc()
        .outerRadius(10)
        .innerRadius(0);

        // define the nodes
node = svg.selectAll("node")
  .data(force.nodes())
  .enter()
  .append("g")
    .attr("class", "node")
    .call(force.drag); 

//create expandall button
var expandAll=svg.append("g");

expandAll.append("svg:rect")
    .attr('fill',"green")
    .attr('x',50)
    .attr('y',30)
    .attr('width',50)
    .attr('height',30)
    .attr('rx',5)
    .attr('ry',5);

expandAll
.append("text")
.attr('style',"fill:white")
.text("Expand all")
.attr('x',50)
.attr('y',50);

//draw circle
    node.selectAll("path")
        .data(function(d, i) {return pie(d.dataVarieties); })
        .enter()
        .append("svg:path")
        .attr("d", arc)
        .attr("transform", "translate(" + -40 + "," + 0 + ")")
        .attr("fill", function(d, i) { return color(varietyColorMap[d.data.group]); });

//draw box
node.append("svg:circle")
.attr('y', -20)
.attr('x', -25)
        .attr("fill","yellow")
        .attr("r",30);

var nodeText=node.append("text");
nodeText.append("tspan")
.attr("x",-15)
.attr("y",0)
.text(function(d) { return d.jobId; });
nodeText.append("tspan")
.attr("x",-15)
.attr("y",10)
.text(function(d) { return d.endTime-d.startTime+" sec"; });
nodeText.append("tspan")
.attr("x",-15)
.attr("y",20)
.text(function(d) { return d.parallelism+" DoP"; });


function stringifyArray(input){
var string="";
for (var i=0;i<input.length;i++){
  string+=input[i]+"<br>";
}
return string;
}

function stringifyVarieties(input){
  var string="";
  for (var i=0;i<input.length;i++){
    if (input[i].value>0){
      string+=input[i].group+"/";
    }
}
//drop trailing slash
return string.slice(0, - 1);
}

var div = node
.append("foreignObject").attr("width", 250).attr("height", 200)
    .attr("y", -40)
    .attr("x", -20)
  .append("xhtml:body")
  .append("div")
    .style("color", "#FFFFFF")
    .style("background-color",function(d) { return color(0);})
    .style("display", "none")
    .style("font-size", "10px")
  .html(function(d) { 
    html="";
    if (d.mapTasks!=null && d.reduceTasks!=null){
      html+=d.mapTasks+" map/"+d.reduceTasks+" reduce<br>"
    }
    return html+"Start:"+d.startTime+"<br>Stop:"+d.endTime+"<br>Variety:"+stringifyVarieties(d.dataVarieties)+"<br>Input:<br>"+stringifyArray(d.rootInputPath)});

expandAll.on("click",function(d){
  toggle(svg.selectAll("div"));

});

//display div on dblclick
node.on("dblclick", function(d) {
  toggle(d3.select(this).selectAll("div"));
});

function toggle(e) {
if(e.style("display") == 'block')
e.style("display", "none");
else
e.style("display", 'block');
tick();
}

/*
//fix a node to the left
  for (var i=0;i<nodes.length;i++){
    if (nodes[i].name=="INPUT"){
            var inp=i;
    }
  }
  nodes[inp].x=50;
  nodes[inp].y=height/2;
  nodes[inp].px = nodes[inp].x;
  nodes[inp].py = nodes[inp].y;
  nodes[inp].fixed=1;
  */

function moveto (d) { 
     return "M"+d.source.x+","+d.source.y; 
  }; 

  function lineto (d) { 
     return " L"+d.target.x+","+d.target.y; 
  }; 

// add the lines, dr=0 forces them to be straight
function tick() {

//does curved lines
    path
    .attr("d", function(d) {
            var dx = d.target.x - d.source.x,
            dy = d.target.y-d.source.y,
            dr = Math.sqrt(dx*dx+dy*dy);
        return "M" + 
            d.source.x + "," + 
            d.source.y + "A" + 
            dr + "," + dr + " 0 0,1 " + 
            d.target.x + "," + 
            d.target.y;
            });

    node
        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

}

</script>